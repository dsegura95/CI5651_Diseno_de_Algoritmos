\documentclass[letterpaper,12pt]{article}
\usepackage{tabularx} % extra features for tabular environment
\usepackage{amsmath}  % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\hypersetup{
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=blue,        % color of internal links
	citecolor=blue,        % color of links to bibliography
	filecolor=magenta,     % color of file links
	urlcolor=blue         
}
\usepackage{blindtext}
\usepackage{mathtools}
\usepackage{tikzsymbols}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
%++++++++++++++++++++++++++++++++++++++++


\begin{document}

\title{Proyecto 2 --- Sudoku Solver Mejorado}
\author{David Segura 13-11341 \& Amin Arriaga 16-10072}
\date{17 de Julio, 2020}
\maketitle

\begin{abstract}
En este proyecto aplicamos todo el contenido estudiado en la materia Diseño de Algoritmos I dictada por el profesor Ricardo Monascal. \textbf{Nota especial:} Gran reconocimiento de agradecimiento al estudiante Amin Arriaga por decidirse a cursar la materia (by D10S).
\end{abstract}


\section{Introducción}

Esta implementación es una continuación del anterior proyecto. Esta etapa consiste en la mejoría del tiempo de ejecución en el resolvedor de \textbf{SAT} mediante estrategias que explicaremos posteriormente.

\section{Mejoras de SAT}

\subsection{Idea presentada en el Proyecto}

La propagación unitaria propuesta por los profesores del curso en el enunciado del proyecto, es un concepto que ya estábamos aplicando en nuestra implementación para la primera parte. Sin embargo, se desarrollaron dos nuevas estructuras para la optimización de la ejecución: \texttt{Variable} y \texttt{Closure}.

\begin{itemize}
	\item \texttt{Variable:} se implementó esta clase para tener una estructura de datos que almacene la información correspondiente a un literal, cuya información almacenada son: las clausulas a la que el literal pertenece, el signo que tiene asignado y una \textit{nube} donde se guardan el signo del literal en distintos estados de ejecución.
	
	Los métodos que esta clase tiene son:
	\begin{itemize}
		\item \texttt{assign}: esta función  se encarga de asignarle el signo al literal.
		
		\item \texttt{add\_closure}: método que agrega una clausula a la información del literal.
	    
	    \item \texttt{save}: método que guarda una copia del signo.
	    
	    \texttt{restaure}: método que restablecerá una copia guardada mediante la llave indicada. También tiene un argumento booleano, que dependiendo del valor que se le pase, elimina la información contenida en  la llave.
	\end{itemize}
	
	\textbf{Tiempo Asintóstico:}
    \begin{itemize}
    	\item \texttt{assign}, \texttt{add\_closure}, \texttt{save}, \texttt{restaure} $\in O(1)$.
    \end{itemize} 
    
    \textbf{Memoria Asintótica:}
    \begin{itemize}
    	\item \texttt{assign} $\in O(?)$.
    	\item \texttt{add\_closure} $\in O(?)$.
    	\item \texttt{save} $\in O(?)$.
    	\item \texttt{restaure} $\in O(?)$.
    \end{itemize}

	\item \texttt{Closure:} se implementó esta clase para tener una estructura de datos que almacene la información correspondiente a una clausula, cuya información almacenada son: los literales que pertenecen a la misma, el tamaño de la clausula, una variable que indica si fue satisfecha (si ya tomó valor de \textit{True} mediante alguno de sus literales), y una \textit{nube} donde se guardan todos esta información ya mencionada en distintos estados de ejecución.
	

	Los métodos que esta clase tiene son:
	\begin{itemize}
		\item \texttt{add}: esta función agrega un literal a la clausula.
		
		\item \texttt{delete}: método se encarga de eliminar los literales indicados pertenecientes a la clausula. Devuelve un booleano que indica si la clausula quedó vacía o no.
	    
	    \item \texttt{save}: método que guarda una copia de toda la información almacenada en la clausula.
	    
	    \texttt{restaure}: método que restablecerá una copia guardada mediante la llave indicada. También tiene un argumento booleano, que dependiendo del valor que se le pase, elimina la información contenida en  la llave.
	\end{itemize}
	
	\textbf{Tiempo Asintóstico:}
    \begin{itemize}
    	\item \texttt{add}, \texttt{save}, \texttt{restaure} $\in O(1)$.
    	
    	\item \texttt{delete} $\in O(n)$, siendo $n$ la cantidad de elementos a eliminar.
    \end{itemize} 
    
    \textbf{Memoria Asintótica:}
    \begin{itemize}
    	\item \texttt{add} $\in O(?)$.
    	\item \texttt{delete} $\in O(?)$.
    	\item \texttt{save} $\in O(?)$.
    	\item \texttt{restaure} $\in O(?)$.
    \end{itemize}

\end{itemize}

\textbf{Memoria Asintótica de Clases:} 
\begin{itemize}
	\item \texttt{Variable} $\in O(?)$.
	\item \texttt{Closure} $\in O(?)$.
\end{itemize}


\subsection{SAT Solver}

Se realizaron algunas modificaciones para mejorar la eficiencia en la ejecución \texttt{laura\_SAT}:\\

Rellena esto amincio
\begin{itemize}
	\item \texttt{update\_C}: se habla de esto que se modifica
	
	\item \texttt{verify\_units}: esto tambien se modifica 
	
	\item Se crea la función \texttt{restaure}
	
	\item \texttt{laura\_SAT}: Aqui tambien jeje.
\end{itemize}

\textbf{Tiempo Asintóstico:}

\begin{itemize}
	\item \texttt{update\_C} $\in O(?)$.

	\item \texttt{verify\_units} $\in O(?)$. 

	\item \texttt{laura\_SAT}$\in O(?)$.
		 
	\item \texttt{restaure} $\in O(?)$.
\end{itemize}

\textbf{Memoria Asintótica:} 
\begin{itemize}
	\item \texttt{update\_C} $\in O(?)$.

	\item \texttt{verify\_units} $\in O(?)$.

	\item \texttt{laura\_SAT} $\in O(?)$. 

	\item \texttt{restaure} $\in O(?)$.
\end{itemize}

\subsection{Salida}

Aqui hablo yo

\section{Conclusiones}

Aqui tambien hablo yo jeje

\end{document}
